import { loadFile } from 'magicast'
import { wordlistsReference } from '~/constants/wordlist-reference'
import type { Wordlist, WordlistAnalysis, WordlistMapModel, WordlistSlug } from '~/models/wordlist'
import * as Anal from '~/utils/analysis'
import { writeFile } from '~/utils/io'

const fileGeneratedComment = `
// This file was generated by scripts/gen-wordlist-map.ts
// Do not modify this file directly
`.trim()
const exportTemplate = (content: string) => `export const WordlistMap = ${content}`

const baseDir = 'constants/generated/wordlists'
const baseOutputDir = 'constants/generated'

const analyzeWordlist = async (wordlistId: WordlistSlug): Promise<{ sample: string[], stats: WordlistAnalysis } | undefined> => {
  const filePath = (filename: string) => `${baseDir}/${filename}`

  const file = await loadFile(filePath(`${wordlistId}.ts`))
  const defaultExport = file.exports.default as string[]
  const words = [...defaultExport ?? []]

  if (!words) {
    return undefined
  }

  const wordCount = words.length

  const longestWordExample = Anal.longestWordExample(words) ?? ''
  const shortestWordExample = Anal.shortestWordExample(words) ?? ''
  const shortestWordLength = shortestWordExample.length
  const longestWordLength = longestWordExample.length

  const meanWordLength = Anal.meanWordLength(words)
  const entropyPerWord = Anal.entropyPerWord(wordCount)
  const entropyPerCharacter = Anal.assumedEntropyPerCharacter(words, shortestWordLength)
  const efficiencyPerCharacter = Anal.efficiencyPerCharacter(words)
  const longestSharedPrefix = Anal.findLongestSharedPrefix(words)
  const uniqueCharacterPrefix = Anal.uniqueCharacterPrefix(words)
  const canBeShortened = Anal.canBeShortened(words)
  const hasDuplicates = Anal.hasDuplicates(words)

  const stats = {
    words: wordCount,
    meanWordLength,
    entropyPerWord,
    entropyPerCharacter,
    efficiencyPerCharacter,
    longestWordExample,
    shortestWordExample,
    shortestWordLength,
    longestWordLength,
    longestSharedPrefix,
    uniqueCharacterPrefix,
    canBeShortened,
    hasDuplicates,
  }

  // TODO: do not return words, have a separate function for fetching words from wordlist
  // generate index.ts file that exports by id
  return {
    sample: words.slice(0, 30),
    stats,
  }
}

const constructWordlistMap = async (): Promise<WordlistMapModel> => {
  console.time('analyzeWordlist')
  const wordlistMap = new Map<WordlistSlug, Wordlist>()

  for await (const wordlist of wordlistsReference) {
    const { slug } = wordlist
    console.time(slug)
    const res = await analyzeWordlist(slug)
    if (!res) {
      console.log(`❌ Failed to analyze wordlist: ${slug}, skipping...`)
      console.timeEnd(slug)
      continue
    }
    const { sample, stats } = res
    wordlistMap.set(slug, { ...wordlist, sample, stats })
    console.timeEnd(slug)
  }
  console.timeEnd('analyzeWordlist')
  return wordlistMap
}

const importStatement = `import type { Wordlist, WordlistSlug } from '~/models/wordlist'`
const setupTemplate = (content: string) => `${fileGeneratedComment}\n\n${importStatement}\n\n${exportTemplate(content)}`

const generateWordlistMap = async () => {
  const wordlistMap = await constructWordlistMap()

  const entries = [...wordlistMap.entries()]
  const content = setupTemplate(`new Map<WordlistSlug, Wordlist>(${JSON.stringify(entries, null, 2)})`)

  const written = await writeFile(`${baseOutputDir}/wordlist-map.ts`, content)
  if (written) {
    console.log(`✅ Generated wordlist map`)
  } else {
    console.log(`❌ Failed to generate wordlist map`)
  }
}

await generateWordlistMap()
